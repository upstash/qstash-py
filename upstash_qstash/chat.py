import json
from typing import Dict, Iterable, List, Literal, TypedDict, Union

from upstash_qstash.error import QstashException
from upstash_qstash.upstash_http import HttpClient


class ChatCompletionMessage(TypedDict, total=False):
    role: Literal["system", "assistant", "user"]
    """The role of the message author."""

    content: str
    """The content of the message."""


ChatModel = Literal[
    "meta-llama/Meta-Llama-3-8B-Instruct", "mistralai/Mistral-7B-Instruct-v0.2"
]


class ChatResponseFormat(TypedDict, total=False):
    type: Literal["text", "json_object"]
    """Must be one of `text` or `json_object`."""


class TopLogprob(TypedDict, total=False):
    token: str
    """The token."""

    bytes: List[int]
    """A list of integers representing the UTF-8 bytes representation of the token.

    Useful in instances where characters are represented by multiple tokens and
    their byte representations must be combined to generate the correct text
    representation. Can be `null` if there is no bytes representation for the token.
    """

    logprob: float
    """The log probability of this token, if it is within the top 20 most likely
    tokens.

    Otherwise, the value `-9999.0` is used to signify that the token is very
    unlikely.
    """


class ChatCompletionTokenLogprob(TypedDict, total=False):
    token: str
    """The token."""

    bytes: List[int]
    """A list of integers representing the UTF-8 bytes representation of the token.

    Useful in instances where characters are represented by multiple tokens and
    their byte representations must be combined to generate the correct text
    representation. Can be `null` if there is no bytes representation for the token.
    """

    logprob: float
    """The log probability of this token, if it is within the top 20 most likely
    tokens.

    Otherwise, the value `-9999.0` is used to signify that the token is very
    unlikely.
    """

    top_logprobs: List[TopLogprob]
    """List of the most likely tokens and their log probability, at this token
    position.

    In rare cases, there may be fewer than the number of requested `top_logprobs`
    returned.
    """


class ChoiceLogprobs(TypedDict, total=False):
    content: List[ChatCompletionTokenLogprob]
    """A list of message content tokens with log probability information."""


class Choice(TypedDict, total=False):
    finish_reason: Literal["stop", "length"]
    """The reason the model stopped generating tokens."""

    index: int
    """The index of the choice in the list of choices."""

    logprobs: ChoiceLogprobs
    """Log probability information for the choice."""

    message: ChatCompletionMessage
    """A chat completion message generated by the model."""


class CompletionUsage(TypedDict, total=False):
    completion_tokens: int
    """Number of tokens in the generated completion."""

    prompt_tokens: int
    """Number of tokens in the prompt."""

    total_tokens: int
    """Total number of tokens used in the request (prompt + completion)."""


class ChatCompletion(TypedDict, total=False):
    id: str
    """A unique identifier for the chat completion."""

    choices: List[Choice]
    """A list of chat completion choices.

    Can be more than one if `n` is greater than 1.
    """

    created: int
    """The Unix timestamp (in seconds) of when the chat completion was created."""

    model: str
    """The model used for the chat completion."""

    object: Literal["chat.completion"]
    """The object type, which is always `chat.completion`."""

    system_fingerprint: str
    """This fingerprint represents the backend configuration that the model runs with.

    Can be used in conjunction with the `seed` request parameter to understand when
    backend changes have been made that might impact determinism.
    """

    usage: CompletionUsage
    """Usage statistics for the completion request."""


class ChunkChoice(TypedDict, total=False):
    delta: ChatCompletionMessage
    """A chat completion delta generated by streamed model responses."""

    finish_reason: Literal["stop", "length"]
    """The reason the model stopped generating tokens."""

    index: int
    """The index of the choice in the list of choices."""

    logprobs: ChoiceLogprobs
    """Log probability information for the choice."""


class ChatCompletionChunk(TypedDict, total=False):
    id: str
    """A unique identifier for the chat completion. Each chunk has the same ID."""

    choices: List[ChunkChoice]
    """A list of chat completion choices.

    Can contain more than one elements if `n` is greater than 1. Can also be empty
    for the last chunk.
    """

    created: int
    """The Unix timestamp (in seconds) of when the chat completion was created.

    Each chunk has the same timestamp.
    """

    model: str
    """The model to generate the completion."""

    object: Literal["chat.completion.chunk"]
    """The object type, which is always `chat.completion.chunk`."""

    system_fingerprint: str
    """
    This fingerprint represents the backend configuration that the model runs with.
    Can be used in conjunction with the `seed` request parameter to understand when
    backend changes have been made that might impact determinism.
    """

    usage: CompletionUsage
    """
    Contains a null value except for the last chunk which contains
    the token usage statistics for the entire request.
    """


class ChatRequest(TypedDict, total=False):
    messages: List[ChatCompletionMessage]
    """A list of messages comprising the conversation so far."""

    model: ChatModel
    """ID of the model to use"""

    frequency_penalty: float
    """
    Number between -2.0 and 2.0.
    Positive values penalize new tokens based on their existing frequency
    in the text so far, decreasing the model's likelihood to repeat
    the same line verbatim.
    """

    logit_bias: Dict[str, int]
    """
    Modify the likelihood of specified tokens appearing in the completion.
    """

    logprobs: bool
    """
    Whether to return log probabilities of the output tokens or not.
    If true, returns the log probabilities of each output token returned
    in the content of message.
    """

    top_logprobs: int
    """
    An integer between 0 and 20 specifying the number of most likely tokens 
    to return at each token position, each with an associated log probability. 
    logprobs must be set to true if this parameter is used.
    """

    max_tokens: int
    """
    The maximum number of tokens that can be generated in the chat completion.

    The total length of input tokens and generated tokens is limited by the 
    model's context length. 
    """

    n: int
    """
    How many chat completion choices to generate for each input message. 
    Note that you will be charged based on the number of generated tokens 
    across all of the choices. Keep n as 1 to minimize costs.
    """

    presence_penalty: float
    """
    Number between -2.0 and 2.0. Positive values penalize new tokens based on 
    whether they appear in the text so far, increasing the model's 
    likelihood to talk about new topics.
    """

    response_format: ChatResponseFormat
    """
    An object specifying the format that the model must output.

    **Important**: when using JSON mode, you must also instruct the model
    to produce JSON yourself via a system or user message. Without this,
    the model may generate an unending stream of whitespace until the
    generation reaches the token limit, resulting in a long-running and
    seemingly "stuck" request. Also note that the message content may
    be partially cut off if `finish_reason="length"`, which indicates the
    generation exceeded max_tokens or the conversation exceeded the max 
    context length.
    """

    seed: int
    """
    If specified, our system will make a best effort to sample deterministically, 
    such that repeated requests with the same seed and parameters should return 
    the same result. Determinism is not guaranteed, and you should refer to the 
    `system_fingerprint` response parameter to monitor changes in the backend.
    """

    stop: Union[str, List[str]]
    """
    Up to 4 sequences where the API will stop generating further tokens.
    """

    stream: bool
    """
    If set, partial message deltas will be sent. Tokens will be sent as
    they become available.
    """

    temperature: float
    """
    What sampling temperature to use, between 0 and 2. Higher values like 0.8 
    will make the output more random, while lower values like 0.2 will make 
    it more focused and deterministic.

    We generally recommend altering this or top_p but not both.
    """

    top_p: float
    """
    An alternative to sampling with temperature, called nucleus sampling, 
    where the model considers the results of the tokens with top_p probability 
    mass. So 0.1 means only the tokens comprising the top 10% probability 
    mass are considered.

    We generally recommend altering this or temperature but not both.
    """


class PromptRequest(TypedDict, total=False):
    system: str
    """The contents of the system message."""

    user: str
    """The contents of the user message."""

    model: ChatModel
    """ID of the model to use"""

    frequency_penalty: float
    """
    Number between -2.0 and 2.0.
    Positive values penalize new tokens based on their existing frequency
    in the text so far, decreasing the model's likelihood to repeat
    the same line verbatim.
    """

    logit_bias: Dict[str, int]
    """
    Modify the likelihood of specified tokens appearing in the completion.
    """

    logprobs: bool
    """
    Whether to return log probabilities of the output tokens or not.
    If true, returns the log probabilities of each output token returned
    in the content of message.
    """

    top_logprobs: int
    """
    An integer between 0 and 20 specifying the number of most likely tokens 
    to return at each token position, each with an associated log probability. 
    logprobs must be set to true if this parameter is used.
    """

    max_tokens: int
    """
    The maximum number of tokens that can be generated in the chat completion.

    The total length of input tokens and generated tokens is limited by the 
    model's context length. 
    """

    n: int
    """
    How many chat completion choices to generate for each input message. 
    Note that you will be charged based on the number of generated tokens 
    across all of the choices. Keep n as 1 to minimize costs.
    """

    presence_penalty: float
    """
    Number between -2.0 and 2.0. Positive values penalize new tokens based on 
    whether they appear in the text so far, increasing the model's 
    likelihood to talk about new topics.
    """

    response_format: ChatResponseFormat
    """
    An object specifying the format that the model must output.

    **Important**: when using JSON mode, you must also instruct the model
    to produce JSON yourself via a system or user message. Without this,
    the model may generate an unending stream of whitespace until the
    generation reaches the token limit, resulting in a long-running and
    seemingly "stuck" request. Also note that the message content may
    be partially cut off if `finish_reason="length"`, which indicates the
    generation exceeded max_tokens or the conversation exceeded the max 
    context length.
    """

    seed: int
    """
    If specified, our system will make a best effort to sample deterministically, 
    such that repeated requests with the same seed and parameters should return 
    the same result. Determinism is not guaranteed, and you should refer to the 
    `system_fingerprint` response parameter to monitor changes in the backend.
    """

    stop: Union[str, List[str]]
    """
    Up to 4 sequences where the API will stop generating further tokens.
    """

    stream: bool
    """
    If set, partial message deltas will be sent. Tokens will be sent as
    they become available.
    """

    temperature: float
    """
    What sampling temperature to use, between 0 and 2. Higher values like 0.8 
    will make the output more random, while lower values like 0.2 will make 
    it more focused and deterministic.

    We generally recommend altering this or top_p but not both.
    """

    top_p: float
    """
    An alternative to sampling with temperature, called nucleus sampling, 
    where the model considers the results of the tokens with top_p probability 
    mass. So 0.1 means only the tokens comprising the top 10% probability 
    mass are considered.

    We generally recommend altering this or temperature but not both.
    """


class Chat:
    def __init__(self, http: HttpClient):
        self.http = http

    @staticmethod
    def _validate_request(req: ChatRequest):
        has_messages = "messages" in req
        has_model = "model" in req

        if not has_messages or not has_model:
            raise QstashException("'messages' and 'model' must be provided.")

    @staticmethod
    def _to_chat_request(req: PromptRequest) -> ChatRequest:
        system_msg = req.get("system")
        user_msg = req.get("user")

        if not system_msg and not user_msg:
            raise QstashException(
                "At least one of 'system' or 'user' prompt is required"
            )

        messages: List[ChatCompletionMessage] = []
        if system_msg:
            messages.append({"role": "system", "content": system_msg})

        if user_msg:
            messages.append({"role": "user", "content": user_msg})

        chat_req: ChatRequest = {"messages": messages}

        for k, v in req.items():
            if k == "system" or k == "user":
                continue

            chat_req[k] = v  # type: ignore[literal-required]

        return chat_req

    def create(
        self, req: ChatRequest
    ) -> Union[ChatCompletion, Iterable[ChatCompletionChunk]]:
        """
        Creates a model response for the given chat conversation.

        When `stream` is set to `True`, it returns an iterable
        that can be used to receive chat completion delta chunks
        one by one.

        Otherwise, response is returned in one go as a chat
        completion object.
        """
        self._validate_request(req)
        body = json.dumps(req)

        if req.get("stream"):
            return self.http.request_stream(
                {
                    "path": ["llm", "v1", "chat", "completions"],
                    "method": "POST",
                    "headers": {
                        "Content-Type": "application/json",
                        "Connection": "keep-alive",
                        "Accept": "text/event-stream",
                        "Cache-Control": "no-cache",
                    },
                    "body": body,
                }
            )

        return self.http.request(
            {
                "path": ["llm", "v1", "chat", "completions"],
                "method": "POST",
                "headers": {"Content-Type": "application/json"},
                "body": body,
            }
        )

    def prompt(
        self, req: PromptRequest
    ) -> Union[ChatCompletion, Iterable[ChatCompletionChunk]]:
        """
        Creates a model response for the given prompt.

        When `stream` is set to `True`, it returns an iterable
        that can be used to receive chat completion delta chunks
        one by one.

        Otherwise, response is returned in one go as a chat
        completion object.
        """
        chat_req = self._to_chat_request(req)
        return self.create(chat_req)
